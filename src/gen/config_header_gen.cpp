#ifdef _MSC_VER
#define _CRT_SECURE_NO_WARNINGS
#endif /* _MSC_VER */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include <sstream>

#define FOUR_MB (4 * 1024 * 1024)

#define HEADER_VAR_IDENTIFIER "PSFLSL_CONFIG_BUILTIN_HEXSTRING"
#define DOUBLEQUOTE "\""

int hex_encode_char(const char RawChar, char *oHexChar1, char *oHexChar2)
{
	const char Chars[] = "0123456789ABCDEF";
	int Fst = (RawChar >> 0) & 0x0F;
	int Snd = (RawChar >> 4) & 0x0F;
	*oHexChar1 = Chars[Fst];
	*oHexChar2 = Chars[Snd];
	return 0;
}

int hex_encode_buf(
	const char *DataBuf, int LenData,
	char **oHexDataBuf, int *oLenHexData)
{
	int r = 0;

	char *HexDataBuf = NULL;

	if (! (HexDataBuf = (char *)malloc(2 * LenData + 1 /*zero*/)))
		{ r = 1; goto clean; }

	for (int i = 0; i < LenData; i++)
		if (!!(r = hex_encode_char(
			DataBuf[i],
			&HexDataBuf[2*i+0],
			&HexDataBuf[2*i+1])))
		{ r = 1; goto clean; }

	memset(&HexDataBuf[2*LenData], '\0', 1);

	if (oHexDataBuf)
		*oHexDataBuf = HexDataBuf;

	if (oLenHexData)
		*oLenHexData = LenData * 2;

clean:
	if (!!r) {
		if (HexDataBuf)
			free(HexDataBuf);
	}

	return r;
}

int header_equals_extracted(
	const char *DstDataBuf, int LenDstData,
	const char *HexSrcBuf, int LenHexSrc,
	int *oEqual)
{
	int r = 0;

	int Equal = 0;

	std::string data(DstDataBuf, LenDstData);
	size_t idxHeaderVarIdentifier = data.find(HEADER_VAR_IDENTIFIER);
	size_t idxDoubleQuote = data.find(DOUBLEQUOTE, idxHeaderVarIdentifier);
	size_t idxDoubleQuoteClosing = std::string::npos;
	std::string sub;

	if (idxHeaderVarIdentifier == std::string::npos ||
		idxDoubleQuote == std::string::npos)
		{ r = 0; goto noclean; }

	idxDoubleQuoteClosing = data.find(DOUBLEQUOTE, idxDoubleQuote + 1);

	if (idxDoubleQuoteClosing == std::string::npos)
		{ r = 0; goto noclean; }

	sub = data.substr(idxDoubleQuote + 1, idxDoubleQuoteClosing - 1);

	Equal = LenHexSrc == sub.size() && !memcmp(HexSrcBuf, sub.data(), LenHexSrc);

noclean:
	if (oEqual)
		*oEqual = Equal;

clean:

	return r;
}

int header_gen(
	const char *HexSrcBuf, int LenHexSrc,
	char **oDstDataBuf, int *oLenDstData)
{
	int r = 0;

	char *DstDataBuf = NULL;

	std::stringstream ss;
	std::string header;

	ss << "/* generated by config_header_gen.cpp - do not edit */" << std::endl;
	ss << "#define " HEADER_VAR_IDENTIFIER << " "
		<< DOUBLEQUOTE << std::string(HexSrcBuf, LenHexSrc) << DOUBLEQUOTE
		<< std::endl;

	header = ss.str();

	if (! (DstDataBuf = (char *) malloc(header.size() + 1)))
		{ r = 1; goto clean; }

	memmove(DstDataBuf, header.data(), header.size());
	memset(DstDataBuf + header.size(), '\0', 1);

	if (oDstDataBuf)
		*oDstDataBuf = DstDataBuf;

	if (oLenDstData)
		*oLenDstData = header.size();

clean:
	if (!!r) {
		if (DstDataBuf)
			free(DstDataBuf);
	}

	return r;
}

int file_read_small(const char *FName, int *oNumData, char **oData)
{
	int r = 0;

	FILE *f = NULL;
	char *data = NULL;
	int offset = 0;
	size_t cnt = 0;
	
	data = (char *) malloc(FOUR_MB);

	if (!(f = fopen(FName, "rb")))
		{ r = 1; goto clean; }

	while (0 != (cnt = fread(&data[offset], 1, FOUR_MB - offset, f))) {
		offset += cnt;
		if (offset > FOUR_MB)
			break;
	}

	if (ferror(f) || !feof(f))
		{ r = 1; goto clean; }

	if (oNumData)
		*oNumData = offset;

	if (oData)
		*oData = data;

clean:
	if (!!r) {
		if (data)
			free(data);
	}

	if (f)
		fclose(f);

	return r;
}

int file_equal_pair(const char *FNameSrc, const char *FNameDst, int *oEqual)
{
	int r = 0;

	char *DataSrc = NULL;
	int NumDataSrc = 0;
	char *DataDst = NULL;
	int NumDataDst = 0;

	int Equal = 0;

	char *HexSrcBuf = NULL;
	int LenHexSrc = 0;

	/* if reading either file fails - count them not equal */

	if (!!(r = file_read_small(FNameSrc, &NumDataSrc, &DataSrc)))
		{ r = 0; goto noclean; }

	if (!!(r = file_read_small(FNameDst, &NumDataDst, &DataDst)))
		{ r = 0; goto noclean; }

	if (!!(r = hex_encode_buf(DataSrc, NumDataSrc, &HexSrcBuf, &LenHexSrc)))
		{ r = 1; goto clean; }

	if (!!(r = header_equals_extracted(
		DataDst, NumDataDst,
		HexSrcBuf, LenHexSrc,
		&Equal)))
		{ r = 1; goto clean; }

noclean:

	if (oEqual)
		*oEqual = Equal;

clean:
	if (HexSrcBuf)
		free(HexSrcBuf);
	if (DataSrc)
		free(DataSrc);
	if (DataDst)
		free(DataDst);

	return r;
}

int file_copy(const char *FNameSrc, const char *FNameDst)
{
	int r = 0;

	char *DataSrcBuf = NULL;
	int LenDataSrc = 0;

	char *HexSrcBuf = NULL;
	int LenHexSrc = 0;

	char *DataDstBuf = NULL;
	int LenDataDst = 0;

	FILE *f = NULL;
	int offset = 0;
	size_t cnt = 0;

	if (!!(r = file_read_small(FNameSrc, &LenDataSrc, &DataSrcBuf)))
		goto clean;

	if (!!(r = hex_encode_buf(DataSrcBuf, LenDataSrc, &HexSrcBuf, &LenHexSrc)))
		{ r = 1; goto clean; }

	if (!!(r = header_gen(
		HexSrcBuf, LenHexSrc,
		&DataDstBuf, &LenDataDst)))
		{ r = 1; goto clean; }

	if (!(f = fopen(FNameDst, "wb")))
		{ r = 1; goto clean; }

	while (0 != (cnt = fwrite(&DataDstBuf[offset], 1, LenDataDst - offset, f))) {
		offset += cnt;
		if (offset > LenDataSrc)
			break;
	}

	if (ferror(f))
		{ r = 1; goto clean; }

clean:
	if (f)
		fclose(f);
	if (DataDstBuf)
		free(DataDstBuf);
	if (HexSrcBuf)
		free(HexSrcBuf);
	if (DataSrcBuf)
		free(DataSrcBuf);

	return r;
}

int file_copy_if_different(const char *FNameSrc, const char *FNameDst)
{
	int r = 0;

	char *DataSrc = NULL;
	int NumDataSrc = 0;

	int Equal = 0;

	if (!!(r = file_equal_pair(FNameSrc, FNameDst, &Equal)))
		goto clean;

	if (! Equal)
		if (!!(r = file_copy(FNameSrc, FNameDst)))
			goto clean;

clean:

	return r;
}

int main(int argc, char **argv)
{
	int r = 0;

	if (argc < 3)
		{ r = 1; goto clean; }

	if (!!(r = file_copy_if_different(argv[1], argv[2])))
		goto clean;

clean:

	return !!r ? EXIT_FAILURE : EXIT_SUCCESS;
}
